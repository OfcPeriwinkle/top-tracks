import argparse
import logging

from typing import List, Dict

import dotenv
import jaro
import spotipy
import tqdm

from rymscraper import rymscraper, RymUrl
from spotipy.oauth2 import SpotifyOAuth

logging.basicConfig(level=logging.INFO)


def get_args():
    parser = argparse.ArgumentParser(
        description='Create a Spotify playlist based on the top tracks of a given year (or all time)')
    parser.add_argument('--year', type=str, default='all-time',
                        help='The year to get the top tracks from')
    parser.add_argument('--pages', type=int, default=1, help='The number of pages to scrape')
    parser.add_argument(
        '--genres',
        nargs='+',
        default=None,
        help='The genres to filter the top tracks by; separate multiple genres with spaces; '
        'if a genre has a space use a hyphen (e.g. New Wave -> new-wave)')
    return parser.parse_args()


def get_top_tracks(year: str = 'all-time', genres: List[str] = None, pages: int = 1) -> List[Dict]:
    url = RymUrl.RymUrl(year=year, kind='single', language='en',
                        genres=','.join(genres) if genres else None)
    network = rymscraper.RymNetwork()

    try:
        logging.info(f'Getting top tracks from {url}')
        list_rows = network.get_chart_infos(url, max_page=pages)
    except Exception as e:
        logging.error(f'Error getting top tracks: {e}')
    finally:
        network.browser.quit()

    return list_rows


def unique_tracks(tracks: List[str]) -> List[str]:
    """
    Remove duplicates from a list of tracks while preserving the order.

    Taken from https://stackoverflow.com/questions/480214/how-do-i-remove-duplicates-from-a-list-while-preserving-order
    """

    seen = set()
    return [track for track in tracks if not (track in seen or seen.add(track))]


def search_for_track_uris(sp: spotipy.Spotify, tracks: List[Dict]):
    spotify_uris = []

    for track in tqdm.tqdm(tracks, desc='Searching for top tracks on Spotify'):
        songs = track['Album'].split(' / ')

        for song in songs:
            # Search for the track on Spotify using fuzzy matching; using the artist and track
            # filters may cause unexpected results to leak through if RYM and Spotify don't match
            res = sp.search(q=f'{song} by {track["Artist"]}', type='track')

            for item in res['tracks']['items']:
                # Names can be inconsistent between RYM and Spotify; use
                # Jaro-Winkler similarity to see if we have something close enough
                artist_similarity = jaro.jaro_winkler_metric(
                    item["artists"][0]["name"], track["Artist"])
                track_similarity = jaro.jaro_winkler_metric(item["name"], song)

                if artist_similarity > 0.7 and track_similarity > 0.7:
                    spotify_uris.append(item['uri'])
                    break

    return unique_tracks(spotify_uris)


def create_spotify_playlist(sp: spotipy.Spotify, spotify_uris: set, year: str = 'all-time',
                            genres: List[str] = None):
    user = sp.current_user()

    display_genres = [genre.replace("-", " ").title()
                      for genre in genres] if genres else []
    genre_description = f'{", ".join(display_genres)}' if genres else ''
    display_year = year if year != 'all-time' else 'All Time'

    # Add 'the' to the beginning of decades
    if display_year[-1] == 's':
        display_year = f'the {display_year}'

    display_preposition = 'from' if display_year != 'All Time' else 'of'

    res = sp.user_playlist_create(
        user=user['id'],
        name=f'Top {f"{display_genres[0]} " if display_genres else "Tracks "}{"& More " if len(display_genres) > 1 else " "}'
             f'{display_preposition} {display_year}',
        public=False,
        description=f'The top {genre_description.lower()} singles {display_preposition} {display_year} according to Rate Your Music; '
                    'generated by https://github.com/OfcPeriwinkle/top-tracks')

    spotify_uris = list(spotify_uris)
    chunked_uris = [spotify_uris[i:i + 100] for i in range(0, len(spotify_uris), 100)]

    for chunk in tqdm.tqdm(chunked_uris, desc='Adding track chunks to playlist'):
        sp.user_playlist_add_tracks(
            user=user['id'],
            playlist_id=res['id'],
            tracks=chunk)

    return res['external_urls']['spotify']


def main():
    args = get_args()
    scope = "user-library-read,playlist-modify-private"
    sp = spotipy.Spotify(auth_manager=SpotifyOAuth(scope=scope))

    logging.info(f'Getting top tracks for {args.year} from RYM...')
    top_tracks = get_top_tracks(args.year, args.genres, args.pages)

    if not top_tracks:
        logging.error('No tracks found')
        return

    spotify_uris = search_for_track_uris(sp, top_tracks)
    url = create_spotify_playlist(sp, spotify_uris, args.year, args.genres)

    logging.info(f'Playlist created: {url}')


if __name__ == '__main__':
    dotenv.load_dotenv()
    main()
